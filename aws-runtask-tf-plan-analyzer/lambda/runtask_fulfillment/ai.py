import json
import os
import re

import boto3
import botocore

from runtask_utils import generate_runtask_result
from utils import logger, stream_messages, tool_config

# Initialize model_id and region
model_id = os.environ.get("BEDROCK_LLM_MODEL")

# Config to avoid timeouts when using long prompts
config = botocore.config.Config(
    read_timeout=1800, connect_timeout=1800, retries={"max_attempts": 0}
)

session = boto3.Session()
bedrock_client = session.client(
    service_name="bedrock-runtime", config=config
)

# Input is the terraform plan JSON
def eval(tf_plan_json):

    #####################################################################
    ##### Evaluate the Terraform plan output and generate summary #######
    #####################################################################

    logger.info("##### Evaluating Terraform plan output #####")
    prompt = """
    List the resources that will be created, modified or deleted in the following terraform plan using the following rules:
    1. Think step by step using the "thinking" json field
    2. For each resource, include the resource type and action (create, modify, delete)
    3. Use the following schema. Skip the preamble:
    <schema>
    {
        "$id": "https://example.com/arrays.schema.json",
        "$schema": "https://json-schema.org/draft/2020-12/schema",
        "type": "object",
        "properties": {
            "thinking": {
                "type": "string",
                "description": "Think step by step"
            },
            "resources": {
                "type": "string",
                "description": "A list of resources that will be created, modified or deleted"
            }
        }
    }
    </schema>
    Now, list the resources that will be created, modified or deleted in the following terraform plan"""

    prompt += f"""
    <terraform_plan>
    {tf_plan_json["resource_changes"]}
    </terraform_plan>
    """

    # Log the prompt
    logger.info(f"Prompt sent to Bedrock: {prompt}")

    messages = [
        {
            "role": "user",
            "content": [
                {
                    "text": prompt,
                }
            ],
        }
    ]

    system_text = "You are an assistant that helps read infrastructure changes from JSON objects generated by Terraform."

    stop_reason, analysis_response = stream_messages(
        bedrock_client, model_id, messages, system_text
    )

    # Log the Bedrock response
    logger.info(f"Bedrock response: {json.dumps(analysis_response, indent=4)}")

    #####################################################################
    ######### Generate short summary based on the plan output ###########
    #####################################################################

    logger.info("##### Generating short summary #####")
    prompt = f"""
        Analyze the Terraform plan changes for security and FinOps optimizations:
        - Identify any potential security risks (e.g., open ports, overly permissive security groups, or missing encryption).
        - Highlight areas where cost optimization can be applied (e.g., unnecessary resource usage, instance types, or EBS volume types).
        - Take into account that migrating from `gp2`    to `gp3` for EBS volumes presents **no security risk** and **will reduce costs** due to `gp3` being a cost-optimized option without compromising performance.
        - Summarize the changes related to security configurations and cost-saving opportunities.

        Additionally, provide a **security risk score** on a scale from 1 to 10 based on the security risks found, where 1 indicates low to no risk and 10 indicates the highest level of risk.

        After analyzing the plan, include a final section with the security risk score using the format:
        "Security Risk Score: X/10", where X represents the level of risk.

        <terraform_plan>
        {tf_plan_json["resource_changes"]}
        </terraform_plan>
        """


    # Log the summary prompt
    logger.info(f"Summary prompt sent to Bedrock: {prompt}")

    message_desc = [{"role": "user", "content": [{"text": prompt}]}]
    stop_reason, response = stream_messages(
        bedrock_client=bedrock_client,
        model_id=model_id,
        messages=message_desc,
        system_text=system_text,
        stop_sequences=["</result>"],
    )

    # Log the summary response from Bedrock
    logger.info(f"Bedrock summary response: {json.dumps(response, indent=4)}")

    description = response["content"][0]["text"]

    # Extract the security risk score from the LLM response
    security_risk_score = get_security_risk_score(description)

    # Check the status based on the extracted score
    status = check_security_status(security_risk_score)

    # Output the result
    print(f"Security Risk Score: {security_risk_score}/10")
    print(f"Status: {status}")

    logger.info("Terraform plan summary: {}".format(description))

    # Prepare the final summary result
    results = []
    results.append(generate_runtask_result(outcome_id="Plan-Summary", description="Summary of Terraform plan", result=description[:9000], status=status))  # body max limit of 10,000 chars

    runtask_high_level = "Terraform plan analyzer using Amazon Bedrock. Click `view more details` to get the detailed logs."
    return runtask_high_level, results, status


def clean_response(json_str):
    # Remove any tags in the format <tag> or </tag>
    cleaned_str = re.sub(r'<\/?[\w\s]+>', '', json_str)
    last_brace_index = cleaned_str.rfind('}')
    cleaned_str = cleaned_str[:last_brace_index + 1]
    return json.loads(cleaned_str)

# Function to check the status based on the Security Risk Score
def check_security_status(score, threshold=7):
    if score is not None:
        if score > threshold:
            return "failed"
        else:
            return "passed"
    else:
        return "passed"  # In case no score is found


# Function to extract the Security Risk Score
def get_security_risk_score(response_text):
    # Use regex to find the security risk score in the format "Security Risk Score: X/10"
    score_match = re.search(r"Security Risk Score:\s*(\d+)/10", response_text)
    
    if score_match:
        # Extract the score and convert it to an integer
        return int(score_match.group(1))
    else:
        # If no score is found, return None
        return None
